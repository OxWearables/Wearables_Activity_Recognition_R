---
title: 'Hidden Markov Models'
output: github_document
---


<!-- NOTES -->
<!-- https://github.com/activityMonitoring/machineLearningPlay/blob/master/rLearningExploration.ipynb -->
<!-- https://github.com/activityMonitoring/Oxford_Wearables_Activity_Recognition -->


```{r setup, include = F}
### Knit Options ###
knitr::opts_knit[['set']](
  base.dir = '~/Git/activity-id-prac-r/',
  root.dir = '~/Git/activity-id-prac-r/'
)

### Chunk Options ###
knitr::opts_chunk[['set']](
  echo = T,
  comment = '',
  dpi = 600,
  warning = F,
  message = F,
  fig.path = 'src/figures/'
)

### General Options ###
options(
  digits = 7, # Default = 7
  scipen = 0, # Default = 0
  width = 120 # Default = 80
)
```


## Setup

Load required packages:

```{r install-packages, results = 'hide'}
### Required Packages ###
pkgs <- c(
  'data.table', # Data import/management.
  'msm' # Hidden Markov models.
)

### Packages to Install ###
pkgs <- pkgs[!{pkgs %in% rownames(installed.packages())}]

### Install (if Required) ###
install.packages(pkgs)

### Tidy Up ###
rm(pkgs)
```

Load required package namespaces:

```{r packages, results = 'hide'}
### Packages ###
library(data.table)
library(msm)
```


<!--## Data import-->

```{r import-more, echo = F, eval = F}
### Paths ###
## Capture-24 Directory ##
dir_cap24 <- '~/Downloads/capture24'

### Import Activity Data ###
files <- list.files(dir_cap24, pattern = '\\.csv\\.gz$', full.names = T)[1:10]
dt <- lapply(
  X = files,
  FUN = fread,
  sep = ',',
  na.strings = ''
)
subj <- basename(files)
subj <- regmatches(subj, regexpr('\\d+', subj))
subj <- as.integer(subj)
invisible(
  mapply(
    FUN = function(x, subj) x[, id := subj],
    x = dt,
    subj = subj,
    SIMPLIFY = F
  )
)

dt <- rbindlist(dt)
setcolorder(dt, 'id')
setorder(dt, id, time)

### Import Annotations Labels ###
dt_dic <- fread(
  file = file.path(dir_cap24, 'annotation-label-dictionary.csv'), # File path.
  sep = ',' # Delimiter.
)

### Make Life a Little Easier for Ourselves ###
## Descriptive Padding ##
setnames(dt_dic, sub('^label:', '', names(dt_dic))) # Swap out special characters.

### Create New Factor Representation of the Willets 2018 Variable ###
dt_dic[, label := factor(
  x = Willetts2018,
  levels = c('sleep', 'vehicle', 'sit-stand', 'mixed', 'walking', 'bicycling'),
  labels = c('Sleep', 'Vehicle', 'SitStand', 'Mixed', 'Walking', 'Cycling')
)]

### Translate Annotations Using Willetts' 2018 Labels ###
dt <- merge(
  x = dt, # Data table `x`.
  y = dt_dic[, .(annotation, label)], # Data table `y`.
  by = 'annotation', # Join column.
  all.x = T, # Left join.
  sort = F # Don't sort by join column.
)

### Drop annotation Column ###
dt[, annotation := NULL]

### Drop Unused Factor Levels ###
dt[, label := droplevels(label)]

### Group Data into 30s Windows ###
breaks <- with(dt, seq(min(time), max(time), by = 30))
dt[, tgrp := cut(
  x = time,
  breaks = breaks,
  labels = paste0('T', seq_len(length(breaks) - 1L)),
  include.lowest = T
), by = id]; rm(breaks)
setcolorder(dt, c('id', 'tgrp', 'time', 'label')) # Reorder columns.

### Mode Function ###
Mode <- function(x) {
  uniqv <- unique(x)
  uniqv[which.max(tabulate(match(x, uniqv)))]
}

### Euclidean Distance Function ###
linalgnorm <- function(x, y, z) {
  v <- sqrt(x^2 + y^2 + z^2)
  return(v)
}

### Feature Extraction ###
dt<- dt[, .(
  time = first(time), # Time reference.
  label = Mode(label), # Majority vote.
  x_mean = mean(x), # Mean of `x`.
  x_sd = sd(x), # SD of `x`.
  y_mean = mean(y), # Mean of `y`.
  y_sd  = sd(y), # SD of `y`.
  z_mean = mean(z), # Mean of `z`
  z_sd = sd(z), # SD of `z`
  v_mean = mean(linalgnorm(x, y, z)), # Mean of the Euclidean distance.
  v_sd = sd(linalgnorm(x, y, z)) # SD of the Euclidean distance.
), by = tgrp]

### Omit NAs ###
dt <- dt[complete.cases(dt)]

### Drop tgrp Variable ###
dt[, tgrp := NULL]
```


## Data import & labels

```{r}
### Paths ###
## Capture-24 Directory ##
dir_cap24 <- '~/Downloads/capture24'

### Data for Participant 040 ###
dt_p001 <- fread(
  file = file.path(dir_cap24, 'P001.csv.gz'), # File path.
  sep = ',', # Delimiter.
  na.strings = '' # Missing data encoding.
)

### Import Annotations Labels ###
dt_dic <- fread(
  file = file.path(dir_cap24, 'annotation-label-dictionary.csv'), # File path.
  sep = ',' # Delimiter.
)

### Make Life a Little Easier for Ourselves ###
## Descriptive Padding ##
setnames(dt_dic, sub('^label:', '', names(dt_dic))) # Swap out special characters.

### Create New Factor Representation of the Willets 2018 Variable ###
dt_dic[, label := factor(
  x = Willetts2018,
  levels = c('sleep', 'vehicle', 'sit-stand', 'mixed', 'walking', 'bicycling'),
  labels = c('Sleep', 'Vehicle', 'SitStand', 'Mixed', 'Walking', 'Cycling')
)]

### Translate Annotations Using Willetts' 2018 Labels ###
dt_p001 <- merge(
  x = dt_p001, # Data table `x`.
  y = dt_dic[, .(annotation, label)], # Data table `y`.
  by = 'annotation', # Join column.
  all.x = T, # Left join.
  sort = F # Don't sort by join column.
)

### Drop annotation Column ###
dt_p001[, annotation := NULL]

### Drop Unused Factor Levels ###
dt_p001[, label := droplevels(label)]

### Group Data into 30s Windows ###
breaks <- with(dt_p001, seq(min(time), max(time), by = 30))
dt_p001[, tgrp := cut(
  x = time,
  breaks = breaks,
  labels = paste0('T', seq_len(length(breaks) - 1L)),
  include.lowest = T
)]; rm(breaks)
setcolorder(dt_p001, c('tgrp', 'time', 'label')) # Reorder columns.

### Mode Function ###
Mode <- function(x) {
  uniqv <- unique(x)
  uniqv[which.max(tabulate(match(x, uniqv)))]
}

### Euclidean Distance Function ###
linalgnorm <- function(x, y, z) {
  v <- sqrt(x^2 + y^2 + z^2)
  return(v)
}

### Feature Extraction ###
dt_p001<- dt_p001[, .(
  time = first(time), # Time reference.
  label = Mode(label), # Majority vote.
  x_mean = mean(x), # Mean of `x`.
  x_sd = sd(x), # SD of `x`.
  y_mean = mean(y), # Mean of `y`.
  y_sd  = sd(y), # SD of `y`.
  z_mean = mean(z), # Mean of `z`
  z_sd = sd(z), # SD of `z`
  v_mean = mean(linalgnorm(x, y, z)), # Mean of the Euclidean distance.
  v_sd = sd(linalgnorm(x, y, z)) # SD of the Euclidean distance.
), by = tgrp]

### Omit NAs ###
dt_p001 <- dt_p001[complete.cases(dt_p001)]

### Drop tgrp Variable ###
dt_p001[, tgrp := NULL]
```


## Hidden Markov model

**NB: Time needs to be numeric & state need to be an integer, or a factor variable with integer levels.**

**NB2: Only observed transitions can be modelled!!**

```{r, eval = F}
### Observed Transitions ###
statetable.msm(state = label, data = dt_p001)

### Number of States ###
n <- length(unique(dt_p001[, label]))

### Transition Matrix (Allowed Transitions) ###
## Initiate Permissive Transition Matrix ##
qmat <- matrix(0.1, nrow = n, ncol = n)
diag(qmat) <- 0
dimnames(qmat) <- list(
  from = sort(unique(dt_p001[, label])), # x dimension.
  to = sort(unique(dt_p001[, label])) # y dimension.
)
## Disallowed Transitions ##
qmat[1, 2] <- 0 # Sleep -> Vehicle.
qmat[2, 1] <- 0 # Vehicle -> Sleep.
## Testing ##
qmat[5, 1] <- 0 # Mixed -> Sleep (not observed).
qmat[1, 3:4] <- 0 # Sleep -> c(SitStand, Walking) (not observed).
## View ##
qmat

### Misclassification (Error) Matrix ###
## Allow Errors Between Adjacent States ##
emat <- matrix(0.1, nrow = n, ncol = n)
diag(emat) <- 0
dimnames(emat) <- list(
  underlying = sort(unique(dt_p001[, label])), # x dimension.
  observed = sort(unique(dt_p001[, label])) # y dimension.
)
## View ##
emat

### Model Fit ###
fit_msm <- msm(
  formula = label ~ time,
  data = dt_p001, # Data.
  qmatrix = qmat, # Transition matrix.
  ematrix = emat#, # Error matrix.
  # covariates = ~ x_mean + x_sd + y_mean + y_sd + z_mean + z_sd + v_mean + v_sd # Vars.
)

### Summaries ###
pmatrix.msm(fit_msm)
sojourn.msm(fit_msm) # Sojourn times.
hazard.msm(fit_msm) # Model coefficients.
```

<!-- HERE -->

```{r detach-packages, echo = F, results = 'hide'}
detach('package:msm', unload = T)
```
